# String 相关知识

此时的 String() 实际上是实现了go内部接口 fmt/print.go 的 String 接口，而 Student 实现了这个接口就会直接调用这个接口。但同时内部又调用了 fmt 的方法，又会再次调用 fmt.String 接口，如此重复导致循环调用

```go
type Student struct {
	Name string
}

func (p *Student) String() string {
	return fmt.Sprintf("print: %v", p) // 结构体默认实现 String() 方法，所以当显示实现 String 时会发生循环递归调用
}
```

此时编译器会提示：`Sprintf format %v with arg p causes recursive String method call`

# Panic / Recover 相关知识

- `panic` 能中断程序控制流，并**递归调用程序中 `defer` 代码段**
- `recover` 可以中止 `panic` 造成的程序崩溃。**它是一个只能在 `defer` 中发挥作用的函数，在其他作用域中调用不会发挥作用；**

# for 循环

```go
wg := sync.WaitGroup{}
// 1
wg.Add(5)
for _, i := range [5]int{1, 2, 3, 4, 5} {
  go func() {
    fmt.Println(i)
    wg.Done()
  }()
}
wg.Wait()
// 2
wg.Add(5)
fmt.Println("")
for _, i := range [5]int{1, 2, 3, 4, 5} {
  go func(i int) {
    fmt.Println(i)
    wg.Done()
  }(i)
}
wg.Wait()
```

第 2 段代码的输出这里有个误区，就是以为开启了 5 个协程运行，肯定顺序是随机的。其实通过调用我们发现**第一个运行输出永远都是 5，也就是最后一个循环体**。为什么会这样呢？

其实输出顺序是受调度器决定到底执行哪一个的。其实我们通过观察源码以及《Go语言设计与实现》中的[调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)介绍中我们可知。我们在开启 G 的时候 go 是会将这些 G push 到一个队列中的，由 P 来控制 M 与 G 的运行。当创建一 个 G 时，会优先放入到下一个调度的 runnext 字段上作为下一次优先调度的 G。因此， 最先输出的是最后创建的G，也就是 5。

```go
func newproc(siz int32, fn *funcval) {
	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
	gp := getg()
	pc := getcallerpc()
	systemstack(func() {
    // 这里就是初始化 g
		newg := newproc1(fn, argp, siz, gp, pc)

		_p_ := getg().m.p.ptr()
    // 调度 g
		runqput(_p_, newg, true)

		if mainStarted {
			wakep()
		}
	})
}

func runqput(_p_ *p, gp *g, next bool) {
	if randomizeScheduler && next && fastrand()%2 == 0 {
		next = false
	}

	if next {
	retryNext:
		oldnext := _p_.runnext
    // 当 next 是 true 时总会将新进来的 G 放入下一次调度字段中
		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
			goto retryNext
		}
		if oldnext == 0 {
			return
		}
		// Kick the old runnext out to the regular run queue.
		gp = oldnext.ptr()
	}

retry:
	h := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with consumers
	t := _p_.runqtail
	if t-h < uint32(len(_p_.runq)) {
		_p_.runq[t%uint32(len(_p_.runq))].set(gp)
		atomic.StoreRel(&_p_.runqtail, t+1) // store-release, makes the item available for consumption
		return
	}
	if runqputslow(_p_, gp, h, t) {
		return
	}
	// the queue is not full, now the put above must succeed
	goto retry
}
```

# 关于组合继承

# 锁

```go
type UserAges struct {
	ages map[string]int
	mu   sync.Mutex
	rw   sync.RWMutex
}

func (ua *UserAges) Add(name string, age int) {
	ua.mu.Lock()
	defer ua.mu.Unlock()
	ua.ages[name] = age
}
func (ua *UserAges) Get(name string) int {
	if age, ok := ua.ages[name]; ok { // 并发时会爆异常，fatal error: concurrent map read and map write，应该该用读写锁
		return age
	}
	return -1
}
func (ua *UserAges) Add2(name string, age int) {
	ua.rw.Lock()
	defer ua.rw.Unlock()
	ua.ages[name] = age
}

func (ua *UserAges) Get2(name string) int {
	ua.rw.RLock()
	defer ua.rw.RUnlock()
	if age, ok := ua.ages[name]; ok {
		return age
	}
	return -1
}
```

#   关于 Channel

Q：对已经关闭的的 chan 进行读写，会怎么样？

A：分两种情况；

- 已经关闭的 channell 中没有值了，这个时候往里面写则会 panic
- 当 channel 还有值时，能够正常读取里面的数据。**当没有值时，也会正常读取成功，返回的是默认值**

# 关于内存逃逸分析

如何查看自己写的代码有没有发生内存逃逸呢？也就是变量由栈变成了堆分配

如下面代码：

```go
type AA struct {
	s string
}

func foo(s string) *AA {
	a := new(AA)
	a.s = s
	return a
}

func main() {
	a := foo("hello")
	b := a.s + " world"
	c := b + "!"
	fmt.Println(c)	
}
```

通过执行 `go build -gcflags=-m ./main.go` 输出如下内容：

```c#
# command-line-arguments
.\main.go:138:6: can inline foo
.\main.go:128:10: inlining call to foo
.\main.go:131:13: inlining call to fmt.Println
.\main.go:143:6: can inline proc
.\main.go:148:13: inlining call to fmt.Println
.\main.go:165:10: inlining call to sync.(*RWMutex).RLock
.\main.go:156:10: inlining call to sync.(*RWMutex).RLock
.\main.go:177:6: can inline f
.\main.go:174:5: can inline init
.\main.go:128:10: new(AA) does not escape
.\main.go:129:11: a.s + " world" does not escape
.\main.go:130:9: b + "!" escapes to heap
.\main.go:131:13: c escapes to heap
.\main.go:131:13: []interface {}{...} does not escape
.\main.go:138:10: leaking param: s
.\main.go:139:10: new(AA) escapes to heap
.\main.go:146:11: leaking param: index
.\main.go:148:13: index escapes to heap
.\main.go:148:13: a escapes to heap
.\main.go:148:13: b escapes to heap
.\main.go:148:13: ret escapes to heap
.\main.go:148:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

上述内容的关键词 `not escape` 就代表了没有发生内存逃逸，而 `escapes to heap` 就代表变量逃逸到了堆上分配了。

能引起变量逃逸到堆上的场景有以下场景：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

> 上述内容来自：https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ

# Go 语言调度机制

GMP 模型实现了 Go 语言的 CSP 并发模型以及调度机制。

- 调度时机：什么时候会发生调度？
- 调度策略：使用什么策略来挑选下一个进入运行的 goroutine？
- 切换机制：如何把挑选出来的 goroutine 放到 CPU 上运行？

第一步，从**全局运行队列中寻找 goroutine**。为了保证调度的公平性，每个工作线程每经过61次调度就需要优先尝试从全局运行队列中找出一个goroutine来运行，这样才能保证位于全局运行队列中的goroutine得到调度的机会。全局运行队列是所有工作线程都可以访问的，所以在访问它之前需要加锁。

第二步，从**工作线程本地运行队列中寻找 goroutine**。如果不需要或不能从全局运行队列中获取到goroutine则从本地运行队列中获取。处理器本地的运行队列是一个使用**数组构成的环形链表**，它最多可以存储 256 个待执行任务。

第三步，从其它工作线程的运行队列中偷取 goroutine。如果上一步也没有找到需要运行的 goroutine，则调用 findrunnable 从其他工作线程的运行队列中偷取goroutine，findrunnable 函数在偷取之前会再次尝试从全局运行队列和当前线程的本地运行队列中查找需要运行的 goroutine。

简而言之：**Go 语言有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列。**